---
phase: 07-schedule-management
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - lib/validations/schedule.ts
  - app/api/schedules/route.ts
  - app/api/schedules/[id]/route.ts
  - app/api/schedules/[id]/duplicate/route.ts
  - components/nav-links.tsx
  - app/(dashboard)/templates/page.tsx
autonomous: true

must_haves:
  truths:
    - "Schedule CRUD API accepts and returns schedule data with nested steps"
    - "Navigation shows 'Templates & Schedules' combined tab"
    - "Templates page has sub-tabs for Templates and Schedules"
    - "Schedule list shows each schedule's name, filing type, and step count"
    - "Empty state shows when no schedules exist"
  artifacts:
    - path: "lib/validations/schedule.ts"
      provides: "Zod schema for schedule with nested steps"
      exports: ["scheduleSchema", "scheduleStepSchema", "ScheduleInput", "ScheduleStepInput"]
    - path: "app/api/schedules/route.ts"
      provides: "GET list and POST create for schedules"
      exports: ["GET", "POST"]
    - path: "app/api/schedules/[id]/route.ts"
      provides: "GET single, PUT update, DELETE for schedules"
      exports: ["GET", "PUT", "DELETE"]
    - path: "app/api/schedules/[id]/duplicate/route.ts"
      provides: "POST duplicate schedule with (Copy) suffix"
      exports: ["POST"]
    - path: "app/(dashboard)/templates/page.tsx"
      provides: "Sub-tabbed view switching between Templates and Schedules"
  key_links:
    - from: "app/api/schedules/route.ts"
      to: "supabase.from('schedules')"
      via: "Supabase PostgREST"
      pattern: "from\\(['\"]schedules['\"]\\)"
    - from: "app/api/schedules/[id]/route.ts"
      to: "supabase.from('schedule_steps')"
      via: "Delete-and-recreate pattern for step updates"
      pattern: "from\\(['\"]schedule_steps['\"]\\)"
    - from: "app/(dashboard)/templates/page.tsx"
      to: "/api/schedules"
      via: "Server component fetch or Supabase direct query"
      pattern: "from\\(['\"]schedules['\"]\\)"
---

<objective>
Create the schedule data layer (validation + API routes) and integrate schedule viewing into the existing Templates page with sub-tab navigation.

Purpose: Establishes the full CRUD backend for schedules and makes schedules discoverable in the UI alongside templates, per the user's locked decision to combine them in one navigation tab.

Output: Working API routes for schedule CRUD + duplicate, Zod validation schema, sub-tabbed Templates & Schedules page with schedule list view.
</objective>

<execution_context>
@C:\Users\ejsch\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\ejsch\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-schedule-management---overrides/07-CONTEXT.md
@.planning/phases/07-schedule-management---overrides/07-RESEARCH.md
@lib/types/database.ts
@lib/validations/template.ts
@app/api/templates/route.ts
@app/api/templates/[id]/route.ts
@app/(dashboard)/templates/page.tsx
@components/nav-links.tsx
@lib/supabase/server.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create schedule validation schema and CRUD API routes</name>
  <files>
    lib/validations/schedule.ts
    app/api/schedules/route.ts
    app/api/schedules/[id]/route.ts
    app/api/schedules/[id]/duplicate/route.ts
  </files>
  <action>
    **1. Create `lib/validations/schedule.ts`:**
    - Zod schema for schedule step: `email_template_id` (uuid string), `days_before_deadline` (int, min 1, max 365), `urgency_level` (enum: "normal", "high", "urgent" -- exactly 3 levels per user decision)
    - Zod schema for schedule: `filing_type_id` (enum matching FilingTypeId), `name` (string, min 1, max 100), `description` (optional string), `steps` (array of step schema, no min/max -- user said no validation rules, trust user), `is_active` (boolean)
    - Export types: `ScheduleInput`, `ScheduleStepInput`
    - NOTE: User locked "No validation rules -- trust user to configure sensible delays and urgency". So do NOT add min step count validation. Steps array can be empty.

    **2. Create `app/api/schedules/route.ts`:**
    - GET: Fetch all schedules from `schedules` table. Try FK embedding with `schedule_steps(id)` to get step count. If FK join fails (project lesson: PostgREST cache issue), fetch schedules only and count steps separately. Order by `created_at` descending.
    - POST: Parse body, validate with `scheduleSchema`. Insert into `schedules` table (filing_type_id, name, description, is_active). If steps provided, insert into `schedule_steps` with step_number derived from array index (1-based). Return created schedule with 201.
    - Follow exact same error handling pattern as `app/api/templates/route.ts` (try-catch on JSON parse, validation error format, 23505 unique constraint check, generic 500).

    **3. Create `app/api/schedules/[id]/route.ts`:**
    - GET: Fetch single schedule by ID. Fetch steps separately from `schedule_steps` ordered by `step_number` ascending. Also fetch the email template name for each step (fetch all email_templates and map by ID -- avoids FK join issues). Return schedule object with `steps` array where each step includes `template_name`.
    - PUT: Parse body, validate with `scheduleSchema`. Update schedule row. For steps: delete ALL existing schedule_steps for this schedule_id, then insert new steps with step_number derived from array index (1-based). This is the delete-and-recreate pattern per Phase 4 decision (schedule_steps are immutable). Return updated schedule.
    - DELETE: Show confirmation is client-side. API just deletes -- CASCADE will remove schedule_steps automatically. Return 204.
    - Use `context: { params: Promise<{ id: string }> }` pattern with `await context.params` (same as existing template [id] route).

    **4. Create `app/api/schedules/[id]/duplicate/route.ts`:**
    - POST: Fetch original schedule and its steps. Create new schedule with same data but name = `${originalName} (Copy)` and `is_active: false`. Copy all steps with new schedule_id. Return new schedule with 201.
    - Per user decision: Duplicate creates copy with "(Copy)" suffix.

    IMPORTANT: The database column is `days_before_deadline` (NOT `delay_days`). The schedule_steps table uses `email_template_id` and `urgency_level`. Check `lib/types/database.ts` ScheduleStep interface for exact column names. The schedules table uses `filing_type_id` (text, not FK).
  </action>
  <verify>
    Run `npx tsc --noEmit` to verify TypeScript compilation passes. Verify all 4 files exist and export the correct handlers.
  </verify>
  <done>
    Zod schema validates schedule input with 3 urgency levels (normal/high/urgent). GET /api/schedules returns schedule list. POST /api/schedules creates schedule with steps. GET /api/schedules/[id] returns schedule with steps and template names. PUT /api/schedules/[id] updates schedule using delete-and-recreate for steps. DELETE /api/schedules/[id] removes schedule (CASCADE removes steps). POST /api/schedules/[id]/duplicate creates copy with "(Copy)" suffix.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add sub-tab navigation and schedule list to Templates page</name>
  <files>
    components/nav-links.tsx
    app/(dashboard)/templates/page.tsx
  </files>
  <action>
    **1. Update `components/nav-links.tsx`:**
    - Change the Templates nav item label from "Templates" to "Templates & Schedules" (per user's locked decision: "Combined with Templates tab").
    - Keep the same href `/templates` and same FileText icon.
    - The `isActive` check already matches `pathname.startsWith(href + "/")` so sub-pages will highlight correctly.

    **2. Rewrite `app/(dashboard)/templates/page.tsx` with sub-tabs:**
    - This is a server component. Add two sub-tabs at the top: "Templates" and "Schedules".
    - Use URL search params to switch tabs: `/templates` or `/templates?tab=schedules`. Default tab is "templates".
    - Since this is a server component, read the tab from searchParams prop (Next.js server component pattern: `searchParams: Promise<{ tab?: string }>`).

    **Templates tab content (default):**
    - Keep the existing template list exactly as-is (fetch from `reminder_templates`, show cards with name/filing type/active badge/step count).
    - Keep "Create Template" button linking to `/templates/new/edit`.

    **Schedules tab content:**
    - Fetch schedules from Supabase: `supabase.from("schedules").select("*").order("created_at", { ascending: false })`.
    - Fetch step counts separately: `supabase.from("schedule_steps").select("schedule_id")` then group/count in JS (avoids FK join issues).
    - Fetch filing_types for name lookup: `supabase.from("filing_types").select("id, name")` then map by ID.
    - Display as simple list per user decision. Each item shows:
      - Schedule name (bold)
      - Filing type name (muted text)
      - Step count (e.g., "3 steps")
    - Each schedule item links to `/schedules/${schedule.id}/edit` (full page editor pattern).
    - "Create Schedule" button links to `/schedules/new/edit`.
    - "Duplicate" button on each schedule card -- calls POST `/api/schedules/${id}/duplicate` then refreshes via `router.refresh()`. Since this is a server component, make the duplicate button a small client component or use a form action.
    - Empty state: "No schedules yet. Create your first reminder schedule to get started." with "Create Schedule" button.

    **Sub-tab styling:**
    - Use simple underline-style tabs matching the project design system. Two links side by side with active state (underline + bold) and inactive state (muted text). Use Tailwind classes consistent with nav-links.tsx active/inactive pattern.
    - The sub-tabs should sit between the page header and the content area.

    **For the Duplicate button on schedule cards:**
    Since the page is a server component, create a small inline client component `ScheduleActions` (can be defined in the same file or a separate component) that handles the duplicate button click (fetch POST to duplicate API, then call `router.refresh()`, show toast). Include a delete button that confirms then calls DELETE API. This pattern matches the existing template editor's delete flow.

    Actually, simpler approach: Make the schedule list section a client component `ScheduleList` that receives the initial data as props from the server component. This allows the duplicate and delete buttons to work without separate component files. Define it within the page file or as a separate component -- use your judgment for cleanest code.
  </action>
  <verify>
    Run `npx tsc --noEmit` for type checking. Run `npm run build` to verify page renders. Navigate to `/templates` and verify both tabs appear. Click "Schedules" tab and verify the schedule list renders (may be empty if no data yet).
  </verify>
  <done>
    Nav shows "Templates & Schedules". Templates page has two sub-tabs. Templates tab shows existing template cards (unchanged behavior). Schedules tab shows schedule list with name, filing type, step count. Each schedule links to edit page. Duplicate button creates copy with "(Copy)" suffix. Delete button with confirmation removes schedule. Empty state displays when no schedules exist. "Create Schedule" button links to `/schedules/new/edit`.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with no errors
2. `npm run build` succeeds
3. Navigate to `/templates` -- see sub-tabs "Templates" and "Schedules"
4. Templates tab shows existing template list (no regression)
5. Schedules tab shows list (empty state if no data)
6. API routes respond correctly: GET /api/schedules returns [], POST creates schedule
</verification>

<success_criteria>
- Schedule validation schema exports ScheduleInput type with 3 urgency levels (normal/high/urgent)
- All 4 API route files exist and handle CRUD + duplicate
- Navigation label updated to "Templates & Schedules"
- Templates page has working sub-tab navigation between Templates and Schedules views
- Schedule list shows name, filing type, step count per schedule
- Duplicate creates copy with "(Copy)" suffix
- Delete removes schedule with confirmation
- No regression to existing template functionality
</success_criteria>

<output>
After completion, create `.planning/phases/07-schedule-management---overrides/07-01-SUMMARY.md`
</output>
