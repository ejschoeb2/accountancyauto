---
phase: 02-reminder-engine
plan: 03
type: tdd
wave: 1
depends_on: []
files_modified:
  - lib/templates/variables.ts
  - lib/templates/variables.test.ts
  - lib/templates/inheritance.ts
  - lib/templates/inheritance.test.ts
autonomous: true

must_haves:
  truths:
    - "Template variables like {{client_name}} are replaced with actual values"
    - "Unknown variables are left as-is (not removed)"
    - "Field-level overrides merge correctly with base template steps"
    - "Non-overridden fields inherit from base template"
  artifacts:
    - path: "lib/templates/variables.ts"
      provides: "Template variable substitution"
      exports: ["substituteVariables", "AVAILABLE_PLACEHOLDERS"]
    - path: "lib/templates/inheritance.ts"
      provides: "Field-level override resolution"
      exports: ["resolveTemplateForClient"]
  key_links:
    - from: "lib/templates/variables.ts"
      to: "date-fns"
      via: "format and differenceInDays for date variables"
      pattern: "import.*date-fns"
---

<objective>
TDD the template variable substitution system and the field-level override inheritance logic. These are pure functions that transform data -- ideal for test-first development.

Purpose: Templates need reliable variable replacement ({{client_name}} becomes "ABC Ltd") and the inheritance model must correctly merge overrides with base templates so that non-overridden fields always reflect the latest base template.
Output: Tested, working template logic library.
</objective>

<execution_context>
@C:\Users\ejsch\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\ejsch\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-reminder-engine/02-RESEARCH.md
</context>

<feature>
  <name>Template Variable Substitution</name>
  <files>lib/templates/variables.ts, lib/templates/variables.test.ts</files>
  <behavior>
  Takes a template string with {{variable}} placeholders and a context object, returns the string with variables replaced.

  Supported variables:
  - {{client_name}} -> client's company name
  - {{deadline}} -> deadline in long format (e.g., "31 January 2026")
  - {{deadline_short}} -> deadline in short format (e.g., "31/01/2026")
  - {{filing_type}} -> filing type display name (e.g., "Corporation Tax Payment")
  - {{days_until_deadline}} -> integer days remaining
  - {{accountant_name}} -> practice name, defaults to "Peninsula Accounting"

  Test cases:
  - "Dear {{client_name}}" with {client_name: "ABC Ltd"} -> "Dear ABC Ltd"
  - "Due on {{deadline}}" with {deadline: new Date(2026, 0, 31)} -> "Due on 31 January 2026"
  - "{{days_until_deadline}} days left" with deadline 30 days from now -> "30 days left"
  - "Unknown {{foo}} variable" -> "Unknown {{foo}} variable" (preserved, not removed)
  - Multiple variables in one string: "Dear {{client_name}}, your {{filing_type}} is due {{deadline}}"
  - Empty string template -> empty string
  - No variables in template -> returns template unchanged
  - {{accountant_name}} with no value provided -> "Peninsula Accounting" (default)
  </behavior>
  <implementation>
  Create `lib/templates/variables.ts`:

  ```typescript
  interface TemplateContext {
    client_name: string;
    deadline: Date;
    filing_type: string;
    accountant_name?: string;
  }

  export function substituteVariables(template: string, context: TemplateContext): string
  ```

  Use single regex: `template.replace(/\{\{(\w+)\}\}/g, (match, key) => variables[key] ?? match)`

  Build variables record from context:
  - client_name: context.client_name
  - deadline: format(context.deadline, 'dd MMMM yyyy')
  - deadline_short: format(context.deadline, 'dd/MM/yyyy')
  - filing_type: context.filing_type
  - days_until_deadline: differenceInDays(context.deadline, new Date()).toString()
  - accountant_name: context.accountant_name || 'Peninsula Accounting'

  Export `AVAILABLE_PLACEHOLDERS` array with {name, description} for each variable (for display in template editor UI).
  </implementation>
</feature>

<feature>
  <name>Field-Level Override Inheritance</name>
  <files>lib/templates/inheritance.ts, lib/templates/inheritance.test.ts</files>
  <behavior>
  Merges base template steps with client-specific overrides. Only overridden fields are replaced; non-overridden fields always come from the base template.

  Test cases:

  Base template with 3 steps:
  ```
  steps: [
    { step_number: 1, delay_days: 60, subject: "Gentle reminder", body: "Please..." },
    { step_number: 2, delay_days: 30, subject: "Follow-up", body: "We notice..." },
    { step_number: 3, delay_days: 14, subject: "Urgent", body: "Final notice..." }
  ]
  ```

  **No overrides** -> returns base steps unchanged

  **Override step 1 subject only:**
  Override: [{step_index: 0, overridden_fields: {subject: "Custom subject"}}]
  Result: step 1 has subject "Custom subject" but delay_days 60 and body "Please..." from base

  **Override step 2 delay_days and body:**
  Override: [{step_index: 1, overridden_fields: {delay_days: 21, body: "Custom body"}}]
  Result: step 2 has delay_days 21, body "Custom body", subject "Follow-up" from base

  **Multiple step overrides:**
  Override steps 0 and 2 -> both merge correctly, step 1 unchanged

  **Override for non-existent step index (e.g., step_index: 5):**
  -> ignored, no crash

  **Empty overrides array** -> returns base steps unchanged

  **Base template updated (subject changes), override only on body:**
  -> resolved template has NEW subject from base + overridden body
  (This is the key inheritance behavior)
  </behavior>
  <implementation>
  Create `lib/templates/inheritance.ts`:

  ```typescript
  import { TemplateStep } from '@/lib/types/database';

  interface OverrideEntry {
    step_index: number;
    overridden_fields: Partial<Pick<TemplateStep, 'subject' | 'body' | 'delay_days'>>;
  }

  export function resolveTemplateForClient(
    baseSteps: TemplateStep[],
    overrides: OverrideEntry[]
  ): TemplateStep[]
  ```

  Implementation: Map over base steps. For each step, find matching override by step_index. If found, spread base step then override fields (using nullish coalescing for each field). If not found, return base step unchanged.

  Also export:
  ```typescript
  export function getOverriddenFieldNames(
    baseSteps: TemplateStep[],
    overrides: OverrideEntry[]
  ): Map<number, string[]>
  ```
  Returns which fields are overridden per step index (for UI display of what's customized).
  </implementation>
</feature>

<verification>
- All test files pass: `npx vitest run lib/templates/`
- Variable substitution handles all 6 placeholder types
- Override inheritance merges correctly for partial overrides
- Edge cases covered (empty inputs, unknown variables, non-existent step indices)
</verification>

<success_criteria>
- substituteVariables correctly replaces all supported placeholder variables
- Unknown variables are preserved (not removed or errored)
- resolveTemplateForClient merges overrides with base template correctly
- Non-overridden fields always reflect base template values
- All tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/02-reminder-engine/02-03-SUMMARY.md`
</output>
