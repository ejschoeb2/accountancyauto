---
phase: 01-foundation-integration
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - lib/quickbooks/oauth-client.ts
  - lib/quickbooks/token-manager.ts
  - lib/quickbooks/api-client.ts
  - lib/quickbooks/sync.ts
  - app/(auth)/onboarding/page.tsx
  - app/(auth)/onboarding/layout.tsx
  - app/(auth)/onboarding/callback/route.ts
  - app/actions/quickbooks.ts
  - lib/validations/client.ts
autonomous: true

must_haves:
  truths:
    - "Clicking 'Connect QuickBooks' on onboarding page redirects to Intuit OAuth authorization screen"
    - "After authorizing in QuickBooks, user is redirected back and tokens are stored in database"
    - "Client list is automatically synced from QuickBooks immediately after OAuth completes"
    - "OAuth access tokens are proactively refreshed at 50 minutes using a distributed lock"
    - "User is redirected to /clients after successful connection and sync"
    - "OAuth errors redirect back to onboarding with an error message"
  artifacts:
    - path: "lib/quickbooks/oauth-client.ts"
      provides: "Intuit OAuthClient configuration"
      exports: ["getOAuthClient"]
    - path: "lib/quickbooks/token-manager.ts"
      provides: "Token refresh with distributed lock"
      exports: ["TokenManager"]
    - path: "lib/quickbooks/sync.ts"
      provides: "Client sync from QuickBooks"
      exports: ["syncClients"]
    - path: "app/(auth)/onboarding/page.tsx"
      provides: "Onboarding wizard UI"
    - path: "app/(auth)/onboarding/callback/route.ts"
      provides: "OAuth callback handler"
      exports: ["GET"]
    - path: "app/actions/quickbooks.ts"
      provides: "Server actions for OAuth and sync"
      exports: ["initiateQuickBooksOAuth", "handleQuickBooksCallback", "syncClientsAction", "getConnectionStatus"]
  key_links:
    - from: "app/(auth)/onboarding/page.tsx"
      to: "app/actions/quickbooks.ts"
      via: "server action call"
      pattern: "initiateQuickBooksOAuth"
    - from: "app/(auth)/onboarding/callback/route.ts"
      to: "app/actions/quickbooks.ts"
      via: "handleQuickBooksCallback + syncClientsAction"
      pattern: "handleQuickBooksCallback.*syncClients"
    - from: "lib/quickbooks/sync.ts"
      to: "Supabase clients table"
      via: "upsert on quickbooks_id"
      pattern: "upsert.*onConflict.*quickbooks_id"
    - from: "lib/quickbooks/token-manager.ts"
      to: "Supabase locks table"
      via: "distributed lock acquire/release"
      pattern: "locks.*insert|delete"
---

<objective>
Implement QuickBooks Online OAuth 2.0 connection flow, token management with distributed lock, client sync, and the onboarding wizard UI.

Purpose: Enable the accountant to connect their QuickBooks account and automatically pull their client list -- the foundational data that all metadata management depends on.
Output: Working OAuth flow (connect -> authorize -> callback -> sync -> redirect), token management with proactive refresh, and onboarding wizard.
</objective>

<execution_context>
@C:\Users\ejsch\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\ejsch\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation-integration/01-RESEARCH.md
@.planning/phases/01-foundation-integration/01-CONTEXT.md
@.planning/phases/01-foundation-integration/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: QuickBooks OAuth client, token manager, and client sync</name>
  <files>
    lib/quickbooks/oauth-client.ts
    lib/quickbooks/token-manager.ts
    lib/quickbooks/api-client.ts
    lib/quickbooks/sync.ts
    lib/validations/client.ts
  </files>
  <action>
    **OAuth client (`lib/quickbooks/oauth-client.ts`):**

    Create and export `getOAuthClient()` that returns a configured `intuit-oauth` OAuthClient instance. Read config from validated env vars. Set environment to 'sandbox' or 'production' based on QUICKBOOKS_ENVIRONMENT.

    **Token manager (`lib/quickbooks/token-manager.ts`) -- follow Pattern 1 from research:**

    Create `TokenManager` class with:
    - `getValidToken(): Promise<string>` -- checks token expiry, proactively refreshes at 50 minutes before expiry (REFRESH_THRESHOLD_MS = 50 * 60 * 1000). Uses distributed lock via Supabase `locks` table.
    - `acquireLock(lockName: string): Promise<boolean>` -- inserts row into `locks` table with unique constraint. Returns false on conflict (another process holds lock). Lock timeout: 10 seconds.
    - `releaseLock(lockName: string): Promise<void>` -- deletes lock row.
    - `storeTokens(tokens, realmId)` -- stores/updates tokens in `oauth_tokens` table.
    - `getStoredTokens()` -- retrieves current tokens.

    Use the admin Supabase client (service role) for all token operations since these run server-side without user session.

    CRITICAL: Handle token rotation atomically -- QuickBooks issues a NEW refresh token on each refresh, invalidating the old one. Both access_token and refresh_token must be updated in a single database operation.

    Clean up expired locks before acquiring new ones (call `cleanup_expired_locks()` Postgres function).

    **API client (`lib/quickbooks/api-client.ts`):**

    Create `getQuickBooksClient()` that:
    1. Gets a valid token via TokenManager
    2. Gets realm_id from stored tokens
    3. Returns a configured `node-quickbooks` instance

    **Client sync (`lib/quickbooks/sync.ts`):**

    Create `syncClients()` that:
    1. Gets QuickBooks client via `getQuickBooksClient()`
    2. Queries all active customers using `findCustomers({ fetchAll: true })`
    3. Maps QuickBooks Customer fields to our schema:
       - quickbooks_id = Customer.Id
       - company_name = Customer.CompanyName || Customer.DisplayName
       - display_name = Customer.DisplayName
       - primary_email = Customer.PrimaryEmailAddr?.Address
       - phone = Customer.PrimaryPhone?.FreeFormNumber
       - active = Customer.Active
       - synced_at = now()
    4. Upserts all clients to Supabase `clients` table with `onConflict: 'quickbooks_id'`
    5. Returns count of synced clients

    Wrap the callback-based `findCustomers` in a Promise for async/await usage.

    **Client validation (`lib/validations/client.ts`):**

    Create Zod schemas for client metadata validation:
    - `clientTypeSchema` -- enum of 'Limited Company', 'Sole Trader', 'Partnership', 'LLP'
    - `updateClientMetadataSchema` -- partial object with client_type, year_end_date, vat_registered, vat_quarter, vat_scheme
    - `bulkUpdateSchema` -- array of { id: uuid, metadata: updateClientMetadataSchema }
  </action>
  <verify>
    Verify all files compile: `npx tsc --noEmit`
    Verify exports: oauth-client exports getOAuthClient, token-manager exports TokenManager, sync exports syncClients, api-client exports getQuickBooksClient, client.ts exports schemas.
  </verify>
  <done>
    QuickBooks OAuth client configured, token manager implements distributed lock with proactive refresh at 50 minutes, client sync maps QBO customers to database and upserts by quickbooks_id, validation schemas defined for client metadata.
  </done>
</task>

<task type="auto">
  <name>Task 2: Onboarding wizard UI and OAuth callback route</name>
  <files>
    app/(auth)/onboarding/page.tsx
    app/(auth)/onboarding/layout.tsx
    app/(auth)/onboarding/callback/route.ts
    app/actions/quickbooks.ts
  </files>
  <action>
    **Server actions (`app/actions/quickbooks.ts`):**

    Create server actions (use `'use server'` directive):

    1. `initiateQuickBooksOAuth()` -- creates OAuthClient, generates authorization URL with scope `com.intuit.quickbooks.accounting`, returns the URL string.

    2. `handleQuickBooksCallback(code: string, realmId: string)` -- exchanges authorization code for tokens using OAuthClient, stores tokens via TokenManager.

    3. `syncClientsAction()` -- calls syncClients() from lib/quickbooks/sync.ts. Returns { success: boolean, count: number }.

    4. `getConnectionStatus()` -- checks if valid OAuth tokens exist in database. Returns { connected: boolean, realmId?: string }.

    5. `disconnectQuickBooks()` -- deletes all rows from oauth_tokens table. Returns void.

    **Onboarding layout (`app/(auth)/onboarding/layout.tsx`):**

    Simple centered layout. No navigation (user hasn't connected yet). White background, vertically centered content area. max-w-2xl.

    **Onboarding wizard page (`app/(auth)/onboarding/page.tsx`) -- per user decision: wizard is first thing accountant sees:**

    Client component with step-based wizard flow. Steps: 'welcome' | 'connecting' | 'syncing' | 'complete' | 'error'.

    Step 'welcome' (initial):
    - Heading: "Welcome to Peninsula Accounting"
    - Subtext: "Connect your QuickBooks Online account to get started."
    - Button: "Connect QuickBooks Online" (styled with Intuit blue #0077C5)
    - On click: calls `initiateQuickBooksOAuth()` server action, sets step to 'connecting', then `window.location.href = authUrl`

    Step 'connecting':
    - "Connecting to QuickBooks..." with loading spinner
    - (This step shows briefly before redirect)

    Step 'syncing':
    - "Syncing your clients..." with loading spinner and progress text
    - This step is shown when returning from OAuth callback via query param `?syncing=true`

    Step 'complete':
    - "All set! [N] clients synced."
    - Button: "Go to Clients" -> navigates to /clients

    Step 'error':
    - "Something went wrong" with error message from query param `?error=...`
    - Button: "Try Again" -> resets to 'welcome' step

    Check URL params on mount:
    - If `?syncing=true&count=N` -> show 'complete' step with count
    - If `?error=...` -> show 'error' step with message

    **OAuth callback route (`app/(auth)/onboarding/callback/route.ts`):**

    GET handler:
    1. Extract `code` and `realmId` from query params
    2. If missing, redirect to `/onboarding?error=oauth_failed`
    3. Call `handleQuickBooksCallback(code, realmId)`
    4. Call `syncClientsAction()` to auto-sync immediately (locked decision: no confirmation step)
    5. Redirect to `/onboarding?syncing=true&count={result.count}`
    6. On any error, redirect to `/onboarding?error=sync_failed`

    Wrap everything in try/catch. Log errors server-side but show generic message to user.
  </action>
  <verify>
    Run `npm run build` to confirm all pages and routes compile.
    Verify the onboarding page renders at /onboarding (run dev server, check for no errors).
    Verify the callback route exists at /onboarding/callback.
  </verify>
  <done>
    Onboarding wizard shows welcome screen with "Connect QuickBooks" button as the first thing the accountant sees. OAuth flow: click button -> Intuit auth page -> callback -> auto-sync -> redirect to clients page. Error states handled with retry option. Server actions encapsulate all QuickBooks operations.
  </done>
</task>

</tasks>

<verification>
1. `npm run build` passes
2. OAuth client creates valid authorization URL with correct scope
3. Token manager implements distributed lock (acquireLock/releaseLock)
4. Token manager refreshes proactively at 50 minutes
5. Client sync maps all required QuickBooks fields
6. Onboarding wizard renders with correct step flow
7. Callback route exchanges code, stores tokens, and triggers sync
8. Error states redirect properly with messages
</verification>

<success_criteria>
- Onboarding wizard displays at /onboarding with "Connect QuickBooks Online" button
- Clicking connect redirects to Intuit OAuth authorization page
- OAuth callback exchanges code for tokens and stores them in database
- Client sync pulls all active customers from QuickBooks and upserts to clients table
- Token manager uses distributed lock to prevent refresh race conditions
- Errors in OAuth or sync redirect back to onboarding with error message
- All code compiles and builds without errors
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-integration/01-02-SUMMARY.md`
</output>
