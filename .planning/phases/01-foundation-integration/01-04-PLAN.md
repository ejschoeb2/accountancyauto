---
phase: 01-foundation-integration
plan: 04
type: execute
wave: 3
depends_on: ["01-02"]
files_modified:
  - app/(dashboard)/clients/components/csv-import-dialog.tsx
  - app/(dashboard)/clients/components/csv-import-button.tsx
  - app/actions/csv.ts
  - lib/validations/csv.ts
  - lib/utils/csv-template.ts
autonomous: true

must_haves:
  truths:
    - "Accountant can upload a CSV file and metadata is applied to matching clients immediately (no preview step)"
    - "CSV rows are matched to existing QuickBooks-synced clients by company name (case-insensitive)"
    - "Unmatched CSV rows are skipped and listed in a summary report after import"
    - "CSV values always overwrite existing metadata"
    - "Accountant can download a CSV template with the correct column format"
    - "Import summary shows total rows, matched count, unmatched count, and validation errors"
  artifacts:
    - path: "app/actions/csv.ts"
      provides: "Server action for CSV import processing"
      exports: ["importClientMetadata"]
    - path: "lib/validations/csv.ts"
      provides: "Zod schema for CSV row validation"
      exports: ["csvRowSchema"]
    - path: "app/(dashboard)/clients/components/csv-import-dialog.tsx"
      provides: "CSV upload dialog with results summary"
    - path: "app/(dashboard)/clients/components/csv-import-button.tsx"
      provides: "Button that triggers CSV import dialog"
    - path: "lib/utils/csv-template.ts"
      provides: "CSV template generation for download"
      exports: ["generateCsvTemplate"]
  key_links:
    - from: "app/(dashboard)/clients/components/csv-import-dialog.tsx"
      to: "app/actions/csv.ts"
      via: "importClientMetadata server action"
      pattern: "importClientMetadata"
    - from: "app/actions/csv.ts"
      to: "lib/validations/csv.ts"
      via: "Zod schema validation per row"
      pattern: "csvRowSchema.safeParse"
    - from: "app/actions/csv.ts"
      to: "Supabase clients table"
      via: "name matching + upsert"
      pattern: "company_name.*toLowerCase"
---

<objective>
Implement CSV import for bulk metadata setup with server-side parsing, Zod validation, company name matching, and results summary.

Purpose: Enable the accountant to quickly configure metadata for all clients at once using a CSV file -- the primary use case is one-time initial setup after connecting QuickBooks.
Output: CSV upload dialog with file input, server-side processing, immediate application, and detailed results summary.
</objective>

<execution_context>
@C:\Users\ejsch\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\ejsch\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation-integration/01-RESEARCH.md
@.planning/phases/01-foundation-integration/01-CONTEXT.md
@.planning/phases/01-foundation-integration/01-01-SUMMARY.md
@.planning/phases/01-foundation-integration/01-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: CSV validation schema, template generator, and import server action</name>
  <files>
    lib/validations/csv.ts
    lib/utils/csv-template.ts
    app/actions/csv.ts
  </files>
  <action>
    **CSV validation schema (`lib/validations/csv.ts`) -- follow Pattern 5 from research:**

    Create Zod schema for CSV rows:
    ```
    csvRowSchema = z.object({
      company_name: z.string().min(1, 'Company name is required'),
      client_type: z.enum(['Limited Company', 'Sole Trader', 'Partnership', 'LLP']).optional(),
      year_end_date: z.string().regex(/^\d{4}-\d{2}-\d{2}$/, 'Date must be YYYY-MM-DD format').optional().or(z.literal('')),
      vat_registered: z.enum(['Yes', 'No', 'yes', 'no', 'TRUE', 'FALSE', 'true', 'false', '']).optional()
        .transform(val => val ? ['Yes', 'yes', 'TRUE', 'true'].includes(val) : undefined),
      vat_quarter: z.enum(['Jan-Mar', 'Apr-Jun', 'Jul-Sep', 'Oct-Dec', '']).optional()
        .transform(val => val === '' ? undefined : val),
      vat_scheme: z.enum(['Standard', 'Flat Rate', 'Cash Accounting', 'Annual Accounting', '']).optional()
        .transform(val => val === '' ? undefined : val),
    })
    ```

    Be lenient on input formats (accept various boolean representations, allow empty strings for optional fields). Export `csvRowSchema` and `type CsvRow`.

    **CSV template (`lib/utils/csv-template.ts`):**

    Export `generateCsvTemplate()` that returns a CSV string with:
    - Header row with exact column names
    - 2 example rows showing valid data
    - Comments/notes in the format

    Example:
    ```
    company_name,client_type,year_end_date,vat_registered,vat_quarter,vat_scheme
    "Acme Ltd","Limited Company","2026-03-31","Yes","Jan-Mar","Standard"
    "Jane Smith Trading","Sole Trader","2026-04-05","No","",""
    ```

    Export `CSV_COLUMNS` constant with column descriptions for help text.

    **CSV import server action (`app/actions/csv.ts`) -- follow Pattern 5 from research:**

    Create `importClientMetadata(formData: FormData)` server action:

    1. Extract file from FormData. Validate it's a .csv file and under 1MB.

    2. Read file content as text.

    3. Parse with PapaParse: `Papa.parse(csvContent, { header: true, skipEmptyLines: true, transformHeader: (h) => h.trim().toLowerCase().replace(/\s+/g, '_') })`.
       - Transform headers to match schema (handle "Company Name" -> "company_name" etc.)

    4. Validate each row with csvRowSchema. Collect valid rows and validation errors (with row numbers).

    5. Fetch all existing clients from Supabase (id, company_name).

    6. Match valid CSV rows to existing clients by company_name (case-insensitive, trimmed).
       - Per locked decision: match by company name

    7. For matched rows, build update objects. Per locked decision: CSV values ALWAYS overwrite existing metadata. Only include non-undefined fields from validated row (empty optional fields don't overwrite).

    8. Apply updates using the `bulk_update_client_metadata` Postgres function via Supabase RPC.

    9. Return structured result:
    ```typescript
    {
      success: boolean,
      summary: {
        totalRows: number,
        validRows: number,
        matchedClients: number,
        unmatchedRows: number,
        validationErrors: number,
        updatedClients: number,
      },
      details: {
        unmatchedCompanies: string[],
        validationErrors: Array<{ row: number, errors: string[] }>,
      }
    }
    ```

    Per locked decision: no preview step -- import applies immediately.
  </action>
  <verify>
    Run `npx tsc --noEmit` to verify type safety.
    Verify csvRowSchema handles all valid input formats (Yes/No, true/false, empty strings).
    Verify CSV template generates valid CSV string.
  </verify>
  <done>
    CSV validation schema handles lenient input formats with Zod transforms. Template generator produces downloadable CSV with correct columns and examples. Import server action parses CSV server-side with PapaParse, validates each row, matches by company name (case-insensitive), and applies updates immediately via Postgres bulk update function. Returns detailed summary with matched/unmatched/error counts.
  </done>
</task>

<task type="auto">
  <name>Task 2: CSV import dialog UI and integration with client table page</name>
  <files>
    app/(dashboard)/clients/components/csv-import-dialog.tsx
    app/(dashboard)/clients/components/csv-import-button.tsx
  </files>
  <action>
    **CSV import button (`app/(dashboard)/clients/components/csv-import-button.tsx`):**

    Client component. Simple button that opens the CSV import dialog.
    - Label: "Import CSV"
    - Secondary/outline style (not primary -- primary is for main actions)
    - Icon: upload icon (from lucide-react, included with shadcn)

    This button should be placed in the client table page header area, next to the search/filter controls. Update the client-table.tsx from Plan 03 to include this button in its toolbar area. If Plan 03 hasn't been executed yet (parallel wave), place it as a standalone export that Plan 03's table can import.

    **CSV import dialog (`app/(dashboard)/clients/components/csv-import-dialog.tsx`):**

    Client component using shadcn Dialog. Props: `{ open, onOpenChange, onImportComplete: () => void }`.

    Dialog states: 'upload' | 'importing' | 'results'

    State 'upload' (initial):
    - Title: "Import Client Metadata from CSV"
    - Description: "Upload a CSV file to set metadata for your clients. Rows are matched by company name."
    - File input accepting .csv files only
    - Drag-and-drop zone (nice to have, optional)
    - "Download Template" link/button -> triggers download of CSV template from `generateCsvTemplate()`
    - Help text explaining: "Required column: company_name. Optional: client_type, year_end_date, vat_registered, vat_quarter, vat_scheme"
    - "Import" button (disabled until file selected)

    State 'importing':
    - "Importing..." with loading spinner
    - Disable all buttons

    State 'results':
    - Title: "Import Complete"
    - Summary cards/stats:
      - Total rows processed: {N}
      - Clients updated: {N} (green badge)
      - Unmatched rows: {N} (amber badge, if > 0)
      - Validation errors: {N} (red badge, if > 0)
    - If unmatched > 0: expandable list of unmatched company names
    - If validation errors > 0: expandable list of errors with row numbers
    - "Done" button closes dialog and calls onImportComplete (which triggers data refresh)

    On file select + "Import" click:
    1. Create FormData with the file
    2. Set state to 'importing'
    3. Call `importClientMetadata(formData)` server action
    4. Set state to 'results' with response data
    5. On any error, show error message in dialog

    **Template download implementation:**

    When user clicks "Download Template":
    1. Call `generateCsvTemplate()` from lib/utils/csv-template.ts
    2. Create a Blob with the CSV content
    3. Create a temporary download link and trigger click
    4. Filename: "client-metadata-template.csv"

    **Integration with clients page:**

    This plan's components should be self-contained. The csv-import-button.tsx exports a component that Plan 03's table page can render. If both plans run in parallel, Plan 03 should import CsvImportButton and place it in the toolbar area. If Plan 03 runs first, update the clients page to include the import button.

    After successful import, call `router.refresh()` to re-fetch client data from server.
  </action>
  <verify>
    Run `npm run build` to confirm components compile.
    Verify CSV import dialog renders with file input.
    Verify template download generates valid CSV.
  </verify>
  <done>
    CSV import button and dialog provide the full import flow: click "Import CSV" -> dialog opens -> select file or download template -> click Import -> server processes immediately (no preview per locked decision) -> results summary shows matched/unmatched/errors. Template download provides correct column format. After import, page refreshes to show updated data.
  </done>
</task>

</tasks>

<verification>
1. `npm run build` passes
2. CSV import button appears in the clients page toolbar area
3. Dialog opens with file upload zone and template download
4. Template CSV has correct columns and example data
5. Import processes server-side (not client-side)
6. Company name matching is case-insensitive
7. Unmatched rows are listed in results summary
8. Validation errors show row numbers and messages
9. CSV values overwrite existing metadata (not merge)
10. No preview step (immediate application per locked decision)
11. Page refreshes after successful import
</verification>

<success_criteria>
- Accountant can click "Import CSV" button to open import dialog
- Accountant can download a CSV template with correct format
- Uploading a CSV immediately processes and applies metadata
- Matched clients have their metadata updated (overwrite behavior)
- Unmatched rows are skipped and listed in summary
- Validation errors are reported with row numbers
- Results summary shows clear counts for all outcomes
- Build passes without errors
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-integration/01-04-SUMMARY.md`
</output>
