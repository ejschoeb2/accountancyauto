---
phase: 03-delivery-dashboard
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - app/api/cron/send-emails/route.ts
  - vercel.json
autonomous: true

must_haves:
  truths:
    - "Pending reminders in reminder_queue are sent as emails via Postmark"
    - "Each sent email is logged in email_log with postmark_message_id"
    - "reminder_queue status updates from pending to sent on success, or failed on error"
    - "Cron endpoint is secured with CRON_SECRET authorization header"
    - "Hard bounce emails are never retried"
  artifacts:
    - path: "app/api/cron/send-emails/route.ts"
      provides: "Cron endpoint that processes pending queue entries"
      exports: ["GET"]
    - path: "vercel.json"
      provides: "Cron schedule including send-emails endpoint"
      contains: "/api/cron/send-emails"
  key_links:
    - from: "app/api/cron/send-emails/route.ts"
      to: "lib/email/sender.ts"
      via: "calls sendReminderEmail for each pending entry"
      pattern: "sendReminderEmail"
    - from: "app/api/cron/send-emails/route.ts"
      to: "reminder_queue table"
      via: "queries pending entries and updates status"
      pattern: "status.*pending"
    - from: "app/api/cron/send-emails/route.ts"
      to: "email_log table"
      via: "inserts log entry after each send"
      pattern: "email_log"
---

<objective>
Create the send-emails cron job that processes pending reminder queue entries into actual Postmark emails, logs results to email_log, and updates queue status.

Purpose: This is the critical pipeline that turns scheduled reminders into actual emails. Phase 2's cron marks reminders as "pending" with resolved subject/body. This cron picks them up and delivers them.
Output: /api/cron/send-emails route handler and updated vercel.json cron config.
</objective>

<execution_context>
@C:\Users\ejsch\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\ejsch\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-delivery-dashboard/03-01-SUMMARY.md
@lib/reminders/scheduler.ts
@app/api/cron/reminders/route.ts
@vercel.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create send-emails cron endpoint</name>
  <files>app/api/cron/send-emails/route.ts</files>
  <action>
Create `app/api/cron/send-emails/route.ts`:

1. Set `export const dynamic = 'force-dynamic'` and `export const maxDuration = 300` (5 min Vercel Pro limit, matching existing cron pattern).

2. Export async function GET(request: Request):
   - Verify CRON_SECRET: check `request.headers.get('authorization') === Bearer ${process.env.CRON_SECRET}`. Return 401 if mismatch. Follow the exact same pattern as `app/api/cron/reminders/route.ts`.
   - Use admin Supabase client (import createAdminClient from @/lib/supabase/admin) for service-role access.

3. Query reminder_queue for entries with status = 'pending' and resolved_subject IS NOT NULL and resolved_body IS NOT NULL:
   ```
   supabase.from('reminder_queue')
     .select('*, clients!inner(company_name, primary_email)')
     .eq('status', 'pending')
     .not('resolved_subject', 'is', null)
     .not('resolved_body', 'is', null)
   ```

4. For each pending reminder, process sequentially (not in parallel -- avoid Postmark rate limits):
   a. Check client has primary_email. If not, mark queue entry as 'failed' and skip.
   b. Call sendReminderEmail({ to: client.primary_email, subject: reminder.resolved_subject, body: reminder.resolved_body, clientName: client.company_name, filingType: reminder.filing_type_id }).
   c. On success:
      - Update reminder_queue: status = 'sent', sent_at = now()
      - Insert into email_log: reminder_queue_id, client_id, filing_type_id, postmark_message_id (from result.messageId), recipient_email, subject (resolved_subject), delivery_status = 'sent'
   d. On failure:
      - Update reminder_queue: status = 'failed'
      - Insert into email_log: client_id, filing_type_id, recipient_email, subject, delivery_status = 'failed', bounce_description = error.message
      - Log error but continue processing remaining entries (don't abort the batch)

5. Return JSON response: { success: true, processed: count, sent: successCount, failed: failCount, errors: errorMessages[] }

Important considerations:
- Process entries one at a time in a for loop, not Promise.all (Postmark rate limit safety)
- Always insert email_log entry regardless of success/failure (audit trail)
- Use try/catch around each individual send, not the whole batch
- If a client has no primary_email, log "No email address for client {id}" in errors array
  </action>
  <verify>
Run `npx tsc --noEmit` to verify TypeScript compilation. Check that the route handler follows the same pattern as the existing reminders cron (GET method, CRON_SECRET check, admin client, maxDuration).
  </verify>
  <done>
/api/cron/send-emails endpoint exists, secured with CRON_SECRET, processes pending queue entries sequentially via Postmark, updates queue status, and logs every attempt to email_log.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update vercel.json cron schedule</name>
  <files>vercel.json</files>
  <action>
Update `vercel.json` to add the send-emails cron job. The existing config has:
```json
{
  "crons": [
    { "path": "/api/cron/reminders", "schedule": "0 8,9 * * *" }
  ]
}
```

Add a new cron entry for send-emails. This should run AFTER the reminders cron has had time to process. The reminders cron runs at 8 and 9 UTC (checking for UK 9am). The send-emails cron should run 10 minutes after each to allow time for queue building:

```json
{
  "crons": [
    { "path": "/api/cron/reminders", "schedule": "0 8,9 * * *" },
    { "path": "/api/cron/send-emails", "schedule": "10 8,9 * * *" }
  ]
}
```

This means:
- 8:00 UTC: reminders cron runs (marks due items as pending)
- 8:10 UTC: send-emails cron runs (sends pending items)
- 9:00 UTC: reminders cron runs again (covers BST/GMT transition)
- 9:10 UTC: send-emails cron runs again
  </action>
  <verify>
Read vercel.json and confirm both cron entries exist with correct paths and schedules.
  </verify>
  <done>
vercel.json has two cron entries: reminders at :00 and send-emails at :10, both running at 8 and 9 UTC.
  </done>
</task>

</tasks>

<verification>
- `app/api/cron/send-emails/route.ts` exists with GET handler, CRON_SECRET check, processes pending queue
- `vercel.json` has both cron entries with staggered schedules
- `npx tsc --noEmit` passes
- Cron handler calls sendReminderEmail and inserts email_log entries
- Failed sends don't abort the batch
</verification>

<success_criteria>
The send-emails cron job is ready: it queries pending reminders, sends each via Postmark, updates queue status to sent/failed, and logs every attempt in email_log. The cron schedule is staggered 10 minutes after the existing reminders cron to ensure queue is populated before processing.
</success_criteria>

<output>
After completion, create `.planning/phases/03-delivery-dashboard/03-02-SUMMARY.md`
</output>
