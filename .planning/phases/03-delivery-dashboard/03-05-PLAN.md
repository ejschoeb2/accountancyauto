---
phase: 03-delivery-dashboard
plan: 05
type: execute
wave: 3
depends_on: ["03-04"]
files_modified:
  - app/(dashboard)/dashboard/page.tsx
  - app/(dashboard)/dashboard/components/audit-log-table.tsx
  - app/(dashboard)/clients/[id]/components/client-audit-log.tsx
  - app/(dashboard)/clients/[id]/page.tsx
  - app/(dashboard)/layout.tsx
  - middleware.ts
  - app/page.tsx
autonomous: false

must_haves:
  truths:
    - "Dashboard has an audit log tab showing chronological list of sent reminders"
    - "Client detail page shows per-client audit log of sent reminders"
    - "Audit log entries show client name, filing type, date sent, and delivery status"
    - "Audit log supports client name search and date range filtering"
    - "Dashboard link appears in navigation and is the primary landing page after login"
    - "Authenticated users landing on / are redirected to /dashboard"
  artifacts:
    - path: "app/(dashboard)/dashboard/components/audit-log-table.tsx"
      provides: "Global audit log table with filtering"
      contains: "email_log"
    - path: "app/(dashboard)/clients/[id]/components/client-audit-log.tsx"
      provides: "Per-client audit log section"
      contains: "email_log"
    - path: "app/(dashboard)/layout.tsx"
      provides: "Navigation with Dashboard link"
      contains: "/dashboard"
    - path: "middleware.ts"
      provides: "Redirect / to /dashboard for authenticated users"
      contains: "/dashboard"
  key_links:
    - from: "app/(dashboard)/dashboard/page.tsx"
      to: "app/(dashboard)/dashboard/components/audit-log-table.tsx"
      via: "renders audit log as tab/section on dashboard"
      pattern: "AuditLogTable"
    - from: "app/(dashboard)/dashboard/components/audit-log-table.tsx"
      to: "email_log table"
      via: "queries email_log with filters"
      pattern: "email_log"
    - from: "middleware.ts"
      to: "/dashboard"
      via: "redirect for authenticated users on /"
      pattern: "redirect.*dashboard"
---

<objective>
Add the audit log (global and per-client), update navigation to include Dashboard link, and configure the landing page redirect.

Purpose: The audit log gives the accountant complete visibility into what was sent, when, and whether it was delivered. The navigation and redirect changes make the dashboard the primary interface.
Output: Audit log on dashboard and client detail page, updated navigation, landing page redirect.
</objective>

<execution_context>
@C:\Users\ejsch\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\ejsch\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-delivery-dashboard/03-CONTEXT.md
@.planning/phases/03-delivery-dashboard/03-04-SUMMARY.md
@app/(dashboard)/layout.tsx
@app/(dashboard)/clients/[id]/page.tsx
@middleware.ts
@lib/supabase/middleware.ts
@app/page.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create audit log components and integrate into dashboard and client detail</name>
  <files>
app/(dashboard)/dashboard/components/audit-log-table.tsx
app/(dashboard)/dashboard/page.tsx
app/(dashboard)/clients/[id]/components/client-audit-log.tsx
app/(dashboard)/clients/[id]/page.tsx
  </files>
  <action>
Create `app/(dashboard)/dashboard/components/audit-log-table.tsx`:
- Client component ("use client") with state for filters and pagination
- Props: initialData (first page of audit entries), totalCount (for pagination)
- Displays a table with columns per user decision:
  1. Date Sent (formatted as "DD MMM YYYY HH:mm" using date-fns format)
  2. Client Name
  3. Filing Type
  4. Delivery Status (use a small badge: green "Delivered", amber "Sent", red "Bounced"/"Failed")
- Filters per user decision:
  - Client name search: text input with debounced onChange (500ms)
  - Date range: two date inputs (from/to)
  - Apply filters by fetching from a server action or API endpoint
- Pagination: offset-based (per Claude's discretion from research), show 20 entries per page
  - "Previous" / "Next" buttons with current page indicator
  - Query: supabase.from('email_log').select('*, clients(company_name), filing_types(name)').order('sent_at', { ascending: false }).range(offset, offset + limit - 1)
- When filters change, reset to page 1
- Sort: always by sent_at DESC (newest first, per research anti-patterns)

Create a server action at `app/actions/audit-log.ts` for fetching filtered/paginated audit log data:
```typescript
'use server'
export async function getAuditLog(params: {
  clientSearch?: string;
  dateFrom?: string;
  dateTo?: string;
  clientId?: string; // for per-client filtering
  offset: number;
  limit: number;
})
```
- Build Supabase query with filters applied
- Return { data: AuditEntry[], totalCount: number }

Update `app/(dashboard)/dashboard/page.tsx`:
- Add tab navigation at the top of the main content area (below summary cards):
  - Tab 1: "Client Status" (the existing client status table)
  - Tab 2: "Audit Log" (the new audit log table)
- Use simple client-side tab state (React useState) or URL search params
- Default tab: "Client Status"
- Fetch initial audit log data server-side for first page load (20 entries)

Create `app/(dashboard)/clients/[id]/components/client-audit-log.tsx`:
- Client component showing same audit log table but pre-filtered to the specific client
- Props: clientId: string
- Uses the same getAuditLog server action with clientId filter
- Shows: date sent, filing type, delivery status (no client name column since it's per-client)
- Same pagination (20 per page)
- Date range filter only (no client name search -- already filtered)

Update `app/(dashboard)/clients/[id]/page.tsx`:
- Add the ClientAuditLog component as a new section at the bottom of the client detail page
- Section header: "Reminder History" or "Sent Reminders"
- Pass the client ID to the component
  </action>
  <verify>
Run `npx tsc --noEmit` to verify compilation. Run `npm run build` to verify pages build. Check that audit-log-table.tsx has filters, pagination, and correct columns.
  </verify>
  <done>
Global audit log tab on dashboard shows all sent reminders with client search and date range filters. Per-client audit log on client detail page shows that client's reminder history. Both use offset pagination at 20 per page, sorted by date DESC.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update navigation, landing page redirect, and add Dashboard link</name>
  <files>
app/(dashboard)/layout.tsx
middleware.ts
app/page.tsx
  </files>
  <action>
Update `app/(dashboard)/layout.tsx`:
- Add "Dashboard" as the FIRST navigation link (before Clients, Templates, Calendar)
- Link href="/dashboard"
- This makes the dashboard the primary navigation item

Update the navigation order to:
1. Dashboard (/dashboard)
2. Clients (/clients)
3. Templates (/templates)
4. Calendar (/calendar)

Update `middleware.ts` to redirect authenticated users from / to /dashboard:
- The existing middleware calls updateSession which handles Supabase auth token refresh
- After updateSession, check if the request path is exactly '/'
- If user is authenticated (check supabase.auth.getUser()), redirect to /dashboard
- If user is NOT authenticated and on a protected route, the existing auth flow handles this
- IMPORTANT: Be careful not to break the existing middleware flow. The updateSession function returns a response -- modify the middleware to check the path AFTER session update.

The redirect logic in middleware.ts should be:
```typescript
export async function middleware(request: NextRequest) {
  const response = await updateSession(request);

  // Redirect authenticated users from / to /dashboard
  if (request.nextUrl.pathname === '/') {
    // Check auth by looking for supabase auth cookies
    const supabase = createServerClient(url, key, { cookies: ... });
    const { data: { user } } = await supabase.auth.getUser();
    if (user) {
      return NextResponse.redirect(new URL('/dashboard', request.url));
    }
  }

  return response;
}
```

Note: The middleware approach needs to create a separate Supabase client since updateSession already consumed the cookies. An alternative simpler approach: update `app/page.tsx` to redirect to /dashboard instead of /onboarding (the onboarding flow is complete at this point). The user decision says "landing page after login" which can be handled by:

Simplest approach -- update `app/page.tsx`:
- Change `redirect("/onboarding")` to check auth state first
- If authenticated, redirect to /dashboard
- If not authenticated, redirect to /auth/login or /onboarding
- This is simpler than middleware modification

Choose whichever approach is cleaner given the existing code structure. If the middleware approach is straightforward, prefer it. If it requires significant refactoring, use the page.tsx approach.

Also update middleware matcher to exclude /api/webhooks from auth processing:
- Current matcher: `/((?!_next/static|_next/image|favicon.ico|.*\\.(?:svg|png|jpg|jpeg|gif|webp)$).*)`
- The webhook endpoint at /api/webhooks/postmark needs to work without auth session
- Add exclusion: `/((?!_next/static|_next/image|favicon.ico|api/webhooks|.*\\.(?:svg|png|jpg|jpeg|gif|webp)$).*)`
  </action>
  <verify>
Run `npx tsc --noEmit` to verify compilation. Run `npm run build` to verify the build succeeds. Check:
1. Dashboard link appears first in navigation
2. / redirects to /dashboard for authenticated users
3. Middleware excludes /api/webhooks from auth processing
  </verify>
  <done>
Dashboard link is first in navigation. Authenticated users landing on / are redirected to /dashboard. Webhook endpoint is excluded from auth middleware.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>Complete Phase 3 delivery and dashboard system: email sending cron, webhook delivery tracking, dashboard with summary cards and traffic-light status, audit log (global and per-client), and navigation updates</what-built>
  <how-to-verify>
1. Start dev server: `npm run dev`
2. Navigate to http://localhost:3000 -- should redirect to /dashboard
3. Verify dashboard page shows:
   - 4 summary cards at top (Overdue, Chasing, Sent Today, Paused)
   - Client status table with traffic-light badges (may be empty or show default state)
   - Tab to switch between "Client Status" and "Audit Log"
4. Verify navigation bar has "Dashboard" as first link
5. Click on a client name to go to client detail page
6. Scroll down to verify "Reminder History" / audit log section appears
7. Check that /api/webhooks/postmark is accessible (POST with no auth should work, GET can return 405)
8. Verify no TypeScript errors: `npx tsc --noEmit`
  </how-to-verify>
  <resume-signal>Type "approved" to confirm Phase 3 is complete, or describe any issues</resume-signal>
</task>

</tasks>

<verification>
- Dashboard at /dashboard renders with summary cards and client status table
- Audit log tab on dashboard shows email history with filters
- Per-client audit log on client detail page
- Failed delivery warning banner on dashboard (when applicable)
- Dashboard link first in navigation
- / redirects to /dashboard
- /api/webhooks/postmark excluded from auth middleware
- `npx tsc --noEmit` passes
- `npm run build` succeeds
</verification>

<success_criteria>
Phase 3 is visually and functionally complete: dashboard shows monitoring data, audit logs provide full visibility, navigation is updated, and the dashboard is the landing page. Combined with Plans 01-04, the complete email delivery pipeline is operational from queue processing through delivery tracking to monitoring dashboard.
</success_criteria>

<output>
After completion, create `.planning/phases/03-delivery-dashboard/03-05-SUMMARY.md`
</output>
