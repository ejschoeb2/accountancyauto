---
phase: 03-delivery-dashboard
plan: 03
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - lib/webhooks/postmark-verify.ts
  - app/api/webhooks/postmark/route.ts
autonomous: true

must_haves:
  truths:
    - "Postmark delivery webhooks update email_log delivery_status to 'delivered'"
    - "Postmark bounce webhooks update email_log delivery_status to 'bounced' or 'failed'"
    - "Webhook signature is verified via HMAC-SHA256 before processing"
    - "Hard bounces are marked as permanent failures and distinguished from soft bounces"
  artifacts:
    - path: "lib/webhooks/postmark-verify.ts"
      provides: "HMAC-SHA256 signature verification for Postmark webhooks"
      exports: ["verifyPostmarkWebhook"]
    - path: "app/api/webhooks/postmark/route.ts"
      provides: "Webhook receiver for Postmark delivery and bounce events"
      exports: ["POST"]
  key_links:
    - from: "app/api/webhooks/postmark/route.ts"
      to: "lib/webhooks/postmark-verify.ts"
      via: "calls verifyPostmarkWebhook before processing"
      pattern: "verifyPostmarkWebhook"
    - from: "app/api/webhooks/postmark/route.ts"
      to: "email_log table"
      via: "updates delivery_status based on webhook event type"
      pattern: "email_log.*update|delivery_status"
---

<objective>
Create the Postmark webhook endpoint for receiving email delivery status updates (delivered, bounced, failed) and a signature verification utility.

Purpose: Without webhooks, the system would never know if emails were actually delivered or bounced. This plan closes the delivery tracking loop by updating email_log when Postmark reports delivery events.
Output: HMAC verification utility and POST webhook handler at /api/webhooks/postmark.
</objective>

<execution_context>
@C:\Users\ejsch\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\ejsch\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-delivery-dashboard/03-RESEARCH.md
@.planning/phases/03-delivery-dashboard/03-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create webhook signature verification utility</name>
  <files>lib/webhooks/postmark-verify.ts</files>
  <action>
Create `lib/webhooks/postmark-verify.ts`:

Import crypto from Node.js built-in 'crypto' module.

Export function verifyPostmarkWebhook(rawBody: string, signature: string, secret: string): boolean
- Create HMAC using crypto.createHmac('sha256', secret)
- Update with rawBody
- Digest to base64
- Compare using crypto.timingSafeEqual(Buffer.from(signature), Buffer.from(computed))
- Wrap in try/catch -- return false if Buffer lengths don't match (timingSafeEqual throws on length mismatch)

CRITICAL: Signature verification MUST happen on the raw body string (from request.text()), NEVER on re-stringified JSON. This is the most common webhook verification bug -- JSON.stringify() may produce different byte output than the original payload.
  </action>
  <verify>
Run `npx tsc --noEmit` to verify the module compiles. Check that it uses crypto.timingSafeEqual (not simple === comparison) and that it catches the length mismatch error.
  </verify>
  <done>
verifyPostmarkWebhook function uses HMAC-SHA256 with timing-safe comparison and handles edge cases. Operates on raw body string, not parsed JSON.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Postmark webhook route handler</name>
  <files>app/api/webhooks/postmark/route.ts</files>
  <action>
Create `app/api/webhooks/postmark/route.ts`:

Export async function POST(request: Request):

1. Read raw body FIRST: `const rawBody = await request.text()`
   - MUST use request.text() before any JSON parsing
   - This preserves exact byte sequence for signature verification

2. Get signature header: `request.headers.get('x-postmark-signature')`
   - If missing, return 401 { error: 'Missing signature' }

3. Verify signature: call verifyPostmarkWebhook(rawBody, signature, process.env.POSTMARK_WEBHOOK_SECRET!)
   - If invalid, return 401 { error: 'Invalid signature' }

4. Parse JSON AFTER verification: `const event = JSON.parse(rawBody)`

5. Use admin Supabase client (createAdminClient) since webhooks have no user session.

6. Switch on event.RecordType:

   Case 'Delivery':
   - Find email_log entry by postmark_message_id = event.MessageID
   - Update: delivery_status = 'delivered', delivered_at = event.DeliveredAt
   - If no matching log entry found, log warning but return 200 (don't break webhook)

   Case 'Bounce':
   - Find email_log entry by postmark_message_id = event.MessageID
   - Determine if hard or soft bounce:
     - event.Type === 'HardBounce' -> delivery_status = 'failed', bounce_type = 'HardBounce'
     - event.Type === 'SoftBounce' or 'Transient' -> delivery_status = 'bounced', bounce_type = event.Type
   - Update email_log: delivery_status, bounce_type = event.Type, bounce_description = event.Description
   - For HardBounce: hard bounces are permanent -- mark as 'failed' (NEVER retry per research)
   - For SoftBounce: mark as 'bounced' (future retry logic can pick these up)

   Default:
   - Log warning for unhandled event type, return 200

7. Always return Response.json({ received: true }, { status: 200 })
   - Webhooks MUST return 200 quickly, even on errors
   - Postmark retries on non-2xx responses, causing duplicate processing

Important: This endpoint must NOT be behind auth middleware. Add it to middleware matcher exclusion if needed. Check if the current middleware matcher in middleware.ts already excludes /api routes or if /api/webhooks needs explicit exclusion.
  </action>
  <verify>
Run `npx tsc --noEmit` to verify compilation. Check that:
1. request.text() is called BEFORE JSON.parse
2. Signature verification happens BEFORE event processing
3. Hard bounces set delivery_status to 'failed'
4. Soft bounces set delivery_status to 'bounced'
5. Handler always returns 200 to Postmark
  </verify>
  <done>
Webhook endpoint receives Postmark events, verifies HMAC signature on raw body, handles Delivery and Bounce events by updating email_log, distinguishes hard vs soft bounces, and always returns 200.
  </done>
</task>

</tasks>

<verification>
- `lib/webhooks/postmark-verify.ts` exports verifyPostmarkWebhook with HMAC-SHA256 and timing-safe compare
- `app/api/webhooks/postmark/route.ts` exports POST handler
- Raw body read before JSON parse
- Signature verified before processing
- Hard bounces -> 'failed', soft bounces -> 'bounced'
- Always returns 200
- `npx tsc --noEmit` passes
</verification>

<success_criteria>
Postmark webhook pipeline is complete: incoming delivery and bounce events are verified via HMAC signature and update the email_log table with delivery status, bounce type, and description. Hard bounces are permanently marked as failed.
</success_criteria>

<output>
After completion, create `.planning/phases/03-delivery-dashboard/03-03-SUMMARY.md`
</output>
